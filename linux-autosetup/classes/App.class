# Credit to Maxim Norin https://github.com/mnorin
# for OOP emulation base from https://stackoverflow.com/questions/36771080/creating-classes-and-objects-using-bash-scripting#comment115718570_40981277
# Modified by Aurtzy

# Class named "App" for bash object

# fields
declare -Ag fields

# Handles getting/setting fields.
App.field() {
	if [ "$2" == "=" ]; then
		fields[$1]=$3
	else
		echo ${fields[$1]}
	fi
}

# App class constructor
# Params: $1 = installCommand $2 = sourcePaths
App.constructor() {

	# Command that is used to install App
	if [ ! "$1" ]; then
		App.installCommand = "${DEFAULT_APP_INSTALL_COMMAND//"$app"/App}"
	else
		App.installCommand = "${1//"$app"/App}"
	fi
	
	# Backup type
	if [ ! "$2" ]; then
		App.backupType = $DEFAULT_APP_BACKUP_TYPE
	else
		App.backupType = $2
	fi
	
	# Source paths to be backed up
	App.sourcePathsCount = 0
	App.sourcePathsAdd "${@:3}"
	
	App.installed = 0
	App.backedUp = 0
	
	App.failedInstall = 0
	App.failedBackup = 0
	App.failedBackupSourcesCount = 0
	
	apps+=("App")
}

# Getter/setter methods
App.installCommand() {
	App.field installCommand "$1" "$2"
}
App.backupType() {
	if [[ "$2" != "" && "$2" != 'COPY' && "$2" != 'HARDLINK' ]]; then
		echo "App: Error: Backup type input $2 was not recognized!"
		echo "Script will not continue. Please resolve."
		echo "Exiting..."
		read
		exit 1
	fi
	App.field backupType "$1" "$2"
}
App.sourcePaths() {
	if [ "$2" = '' ]; then
		for (( i=0 ; i < $(App.sourcePathsCount) ; i++ )); do
			App.field sourcePath${i}
		done
	else
		if [ "${3: -1}" = '/' ]; then
			sourcePath=${3::-1}
		fi
		App.field sourcePath${1} "$2" "$sourcePath"
	fi
}
App.sourcePathsCount() {
	declare -i intParam=$2
	App.field sourcePathsCount "$1" "$intParam"
}
App.failedBackupSourcesCount() {
	declare -i intParam=$2
	App.field failedBackupSourcesCount "$1" "$intParam"
}
App.installed() {
	declare -i intParam=$2
	App.field installed "$1" "$intParam"
}
App.backedUp() {
	declare -i intParam=$2
	App.field backedUp "$1" "$intParam"
}
App.backupsInstalled() {
	declare -i intParam=$2
	App.field backupsInstalled "$1" "$intParam"
}
App.failedInstall() {
	declare -i intParam=$2
	App.field failedInstall "$1" "$intParam"
}
App.failedBackup() {
	declare -i intParam=$2
	App.field failedInstall "$1" "$intParam"
}
App.failedBackupSources() {
	if [ "$2" = '' ]; then
		for (( i=0 ; i < $(App.failedBackupSourcesCount) ; i++ )); do
			App.field failedBackupSource${i}
		done
	else
		App.field failedBackupSource${1} "$2" "$3"
	fi
}
App.sourcePathsAdd() {
	declare -i i=$(App.sourcePathsCount)
	for sourcePath in "${@}"; do
		App.sourcePaths "$i" = "$sourcePath"
		i+=1
	done
	App.sourcePathsCount = $i
}
App.failedBackupSourcesAdd() {
	App.failedBackup = 1
	declare -i i=$(App.failedBackupSourcesCount)
	for sourcePath in "${@}"; do
		App.failedBackupSources "$i" = "$sourcePath"
		i+=1
	done
	App.failedBackupSourcesCount = $i
}

# Install App on call
# Also reset to original dir in case command used cd
App.install() {
	echo
	if [ $(App.installed) -eq 1 ]; then
		echo "App: Already installed during this script."
		return 3
	fi
	echo "App: Installing..."
	eval $(App.installCommand)
	if [ $? -ne 0 ]; then
		echo "App: Error: App failed to install."
		App.failedInstall = 1
		return 1
	fi
	cd "$SCRIPT_WORKING_DIR"
	
	if [ "$(App.sourcePaths)" != '' ]; then
		echo
		echo "App: One or more backups were detected."
		if [ $appInstallBackups -eq 1 ]; then
			App.installBackups
		elif [ $appInstallBackups -eq 0 ]; then
			declare -i userIn=$(promptYesNo "Would you like to install them? This will replace existing files.")
			if [ $userIn -eq 1 ]; then
				App.installBackups
			elif [ $userIn -eq 2 ]; then
				appInstallBackups=1
				App.installBackups
			elif [ $userIn -eq -1 ]; then
				appInstallBackups=-1
			fi
		else
			echo "App: Backups will not be installed."
		fi
	fi
	
	App.installed = 1
}

App.installBackups() {
	if [ "$(App.backupsInstalled)" -eq 1 ]; then
		echo "App: Backups already installed."
		return
	fi
	backupDir="$APP_BACKUP_DIR/App"
	IFS=$'\n'
	for sourcePath in $(App.sourcePaths); do
		source="${sourcePath##*"/"}"
		sourceDir="${sourcePath%"/"*}"
		echo
		echo "App: Installing $sourcePath"
		sudo -u $SUDO_USER mkdir -p "$sourceDir"
		if [ "$?" -ne 0 ]; then
			echo "Elevating permissions for mkdir to work..."
			mkdir -p "$sourceDir"
		fi
		cp -a "$backupDir/$source" "$sourceDir"
		if [ $? -ne 0 ]; then
			echo "App: Error: $source could not be installed."
		else
			echo "App: $source was successfully installed!"
		fi
	done
	unset IFS
	App.backupsInstalled = 1
}

# Back up sources
App.backup() {
	echo
	if [ "$(App.backedUp)" -eq 1 ]; then
		echo "App: Already backed up during this script."
		return 3
	elif [ "$(App.sourcePaths)" = '' ]; then
		echo "App: No sourcePaths specified for App."
		return
	else
		backupDir="$APP_BACKUP_DIR/App"
		if [ ! -d "$backupDir" ]; then
			echo "App: Backup directory not found. Making one for you..."
			sudo -u $SUDO_USER mkdir -p "$backupDir"
			if [ "$?" -ne 0 ]; then
				echo "Elevating permissions for mkdir to work..."
				mkdir -p "$backupDir"
			fi
		else
			dump "INITIALIZE" "App"
		fi
		IFS=$'\n'
		for sourcePath in $(App.sourcePaths); do
			echo
			source="${sourcePath##*"/"}"
			sourceDir="${sourcePath%"/"*}"
			
			# Check if sourcePath exists
			if [[ -f "$sourcePath" || -d "$sourcePath" ]]; then
				echo "App: Found: $sourcePath"
				
				# Dump any old backup
				if [[ -f "$backupDir/$source" || -d "$backupDir/$source" ]]; then
					echo "App: Old backup found. Dumping..."
					dump "$backupDir/$source" "App"
					echo "App: Dumped old $source"
				fi
				
				# PERFORM BACKUP
				echo "App: Performing backup..."
				if [ "$(App.backupType)" = "COPY" ]; then
					cp -a "$sourcePath" "$backupDir/$source"
					echo "App: Copied $sourcePath"
				elif [ "$(App.backupType)" = "HARDLINK" ]; then
					cp -al "$sourcePath" "$backupDir/$source"
					echo "App: Hard-linked $sourcePath"
				else
					echo "App: Error: Backup type $(App.backupType) not recognized."
				fi
			else
				echo "App: Error: Could not find $sourcePath"
				App.failedBackupSourcesAdd $sourcePath
				continue
			fi
		done
		unset IFS
		echo "App: Backup completed."
	fi
	App.backedUp = 1
}

